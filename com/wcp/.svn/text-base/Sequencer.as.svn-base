package com.wcp {	import com.wcp.Effect;	import com.wcp.EffectEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	public class Sequencer extends EventDispatcher {		private var _queue:Array = new Array(8);		private var current:int = 0;		private var _playing:Boolean = false;		public function Sequencer() {		}		public function listener(e:Event) {			switch(e.action) {				case EffectEvent.QUEUE_ADD:					this.queue_add(e.effect,e.effectName);				break;				case EffectEvent.QUEUE_DROP:					this.queue_drop(e.effectName);				break;				case Engine.EFFECT_COMPLETE:					trace(Engine.EFFECT_COMPLETE);					if(!hasItems()) {						dispatchEvent(new Event("blackout"));					}					return this.stepper();				break;			}		}		public function queue_drop (idx:int) {			_queue[idx] = null;			dispatchEvent(new EffectEvent(EffectEvent.QUEUE_CHANGE,null,_queue));			return hasItems();		}		public function queue_add (fx:Effect=null,idx:int=-1) {			var k = idx-1;			if(fx == _queue[k])				_queue[k] = null;			else				_queue[k] = fx;			dispatchEvent(new EffectEvent(EffectEvent.QUEUE_CHANGE,null,_queue));			return hasItems();		}		private function isNull (obj:Object,index:int,array:Array):Boolean {			return (obj==null);		};	 	public function go(_play:Object=null) {			if(!hasItems())				return;			_playing = (_play===true || _play===false) ? _play : !_playing;			if(_playing) {				if(_queue[current]!=null) {					dispatchEvent(new EffectEvent(EffectEvent.PLAY,_queue[current]));				}			} else {					dispatchEvent(new EffectEvent(EffectEvent.STOP));			}		}		public function stepper () {			i=0;			current++;			while(_queue[current]==null && i<_queue.length) {				current++;				if(current>=_queue.length)					current=0;				i++;			}			if(_queue[current]!=null && _playing) {				dispatchEvent(new EffectEvent(EffectEvent.PLAY,_queue[current]));			}		}		public function hasItems() {			return !_queue.every(isNull);		}	}}