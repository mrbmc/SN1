package com.wcp {	import flash.events.Event;	import flash.utils.Timer;	import flash.utils.getTimer;	import flash.events.TimerEvent;	import com.wcp.Effect;	import com.wcp.EffectEvent;	import com.wcp.LightEvent;	import com.wcp.DebugEvent;	public class Engine extends Timer{		public var loop:Boolean = false;		public var randomize:Boolean = false;		public var display:Array = new Array(60);		private var _trail:int = 0;		private var _frames:int = 0;		private var _frame:int = 0;		private var _loops:int = 0;		private var _loop:int = 0;		public var fx:Effect;		private var interval:int = 100;		private var time:Number = getTimer();		private var fps:int = 30;		private var _reflect:Boolean = false;		private var _reverse:Boolean = false;		public static var EFFECT_COMPLETE = "effectComplete";		public function Engine () {			for(var i=0;i<60;i++) display[i]=0;			this.addEventListener(TimerEvent.TIMER, this.iteration);			this.speed = 120;			super((1000/fps));		}				public function set speed (bpm:int) {			//convert BPM to BPS, quadrouple it for 16th notes			var bps = (bpm/60)*4;			//convert BPS to ms			interval = (1000/bps);		}		public function get speed ():int {			return Math.round((1000/interval)/4*60);		}				public function get frames():int {			var cellCount = (this.reflect) ? (fx.sequence.length*2) : fx.sequence.length;			return (this.loops>0) ? cellCount : cellCount + trail;		}		public function get loops():int {			return (fx.loops) ? fx.loops : 0;		}		public function get trail():int {			return (_trail>0) ? _trail : fx.trail;		}		public function set trail(n:int):void {			this._trail = n;		}		public function set reverse(b:Boolean):void {			this._reverse = b;		}		public function get reverse():Boolean {			return (this._reverse || fx.reverse);		}		public function set reflect(b:Boolean):void {			this._reflect = b;		}		public function get reflect():Boolean {			return (this._reflect || fx.reflect);		}		public function go (_fx:Effect=null):Boolean {			if(_fx!=null) fx = _fx;			_loop=0;_frame=0;time=getTimer();			this.start();			//return true;		}		private function iteration (t:TimerEvent) {			if(fx==null) return;			if(getTimer()-time < interval/fx.speed)				return;			time = getTimer();			//var index = 0;			//var brightness = 0;			for(i=0;i<60;i++) display[i]=0;//trace("break"+fx.name);			var forward = fx.sequence.slice(0);			var reversed = fx.sequence.slice(0).reverse();			var pattern = (reflect) ? (reverse ? reversed.concat(forward) : forward.concat(reversed) ) : ((reverse) ? reversed : forward);			//loop through the trail iterations			for(i=0;i<=trail;i++){				var tgt = _frame - i;				if(tgt<0 || tgt>=pattern.length) continue;				//loop through LEDs				for(var j=0;j<pattern[tgt].length;j++) {					if(pattern[tgt][j] is Array) {						index = pattern[tgt][j][0];						brightness = pattern[tgt][j][1];					}else {						index = pattern[tgt][j];						brightness = (100-(100/(trail+1)*i));					}					display[index] = brightness*(fx.brightness/100);				}			}			dispatchEvent(new LightEvent(-1,0,display));			_frame++;			if(_frame >= frames) {				//trace(_frame+"/"+frames+"/"+_loop+"/"+loops);				if(_loop<loops || loop) {					_frame=0;//time=0;					if(!loop) _loop++;				} else {					if(trail>0 && _frame <= (frames+trail)) {						//_frame=0;time=0;					} else {						fx = null;						dispatchEvent(new EffectEvent("effectComplete"));						//this.stop();					}				}			}		}		public function blackout() {			fx = null;		}		private function randomizer() {			var en = Math.floor(Math.random()*fx.effects.length);			return fx.effects[en];		}		public function listener (e:EffectEvent) {			//trace(e.effect.name+":"+e.action);			if(e.action==EffectEvent.PLAY) {				dispatchEvent(new DebugEvent(e.effect.name));				this.go(e.effect);			} else if(e.action==EffectEvent.STOP) {				this.fx = null;				for(i=0;i<60;i++) {					dispatchEvent(new LightEvent(i,0));				}			} else if(e.action==EffectEvent.CHANGED) {				if(this.fx==null || this.fx.name==e.effect.name)					this.fx = e.effect;			}			return true;		}	}}